using System;

class Program
{
    static void Main()
    {
                                                            //   ПЕРВЫЙ СПОСОБ   //

        int[,] graph = {
         //   1  2  3  4  5
            { 0, 1, 0, 0, 0 }, // 1
            { 1, 0, 1, 0, 0 }, // 2
            { 0, 1, 0, 0, 0 }, // 3
            { 0, 0, 0, 0, 1 }, // 4
            { 0, 0, 0, 1, 0 }  // 5
        };

        bool[] visit = new bool[5]; // массив, который отслеживает, какие вершины уже посещены (true - посещена, false - не посещена).
        int components = 0;

        for (int i = 0; i < 5; i++) // пройдём по всем вершинам графа
        {
            if (!visit[i]) // если не посещена вершина то это новая компонента
            {
                components++;
                int[] nabor = new int[5]; //храним вершины для обхода
                int Point = 0; // верхушка набора
                nabor[Point++] = i; // с i-вершины начинаем обход

                while (Point > 0) // пока в наборе есть вершины 
                {
                    int Vershina = nabor[--Point]; // достаём верхний элемент из набора
                    if (!visit[Vershina])
                    {
                        visit[Vershina] = true;
                        for (int j = 0; j < 5; j++) // находим соседей вершины
                        {
                            if (graph[Vershina, j] == 1 && !visit[j])  //Если есть связь и j не посещена — сосед Vershina.
                            {
                                nabor[Point++] = j;
                            }
                        }
                    }
                }
            }
        }

        Console.WriteLine("Количество компонентов связанности: " + components);

                                                            //   ВТОРОЙ СПОСОБ   //

        int[,] graph2 = { 
        { 0, 1, 0, 0, 0 }, // Вершина 1 соединена с вершиной 2
        { 1, 0, 1, 0, 0 }, // Вершина 2 соединена с вершинами 1 и 3
        { 0, 1, 0, 0, 0 }, // Вершина 3 соединена с вершиной 2
        { 0, 0, 0, 0, 0 }, // Вершина 4 изолирована
        { 0, 0, 0, 0, 0 }  // Вершина 5 изолирована
        };

        int n = graph2.GetLength(0); // кол-во вершин
        int[] component = new int[n]; // номер компоненты связности для каждой вершины
        int component_count = 0; 
        int[] ochered = new int[n]; // Очередь для обхода графа 
        int start, end; // Указатели начала и конца очереди

        // Проходим по всем вершинам графа
        for (int i = 0; i < n; i++)
        {
            if (component[i] == 0) // Если вершина ещё не принадлежит никакой компоненте
            {
                component_count++; // Начинаем новую компоненту
                start = 0;
                end = 0;
                ochered[end++] = i; // Добавляем текущую вершину в очередь
                component[i] = component_count; // Помечаем её номером текущей компоненты

                // Обход графа в ширину 
                while (start < end)
                {
                    int curr = ochered[start++]; // Достаём вершину из начала очереди
                    for (int j = 0; j < n; j++) // Проверяем все вершины
                    {
                        if (graph2[curr, j] == 1 && component[j] == 0) // Если есть связь и вершина не посещена
                        {
                            component[j] = component_count; // Назначаем ей тот же номер компоненты
                            ochered[end++] = j; // Добавляем вершину в очередь для дальнейшего обхода
                        }
                    }
                }
            }
        }

        Console.WriteLine("Количество компонентов связанности: " + component_count); 
    }
}


